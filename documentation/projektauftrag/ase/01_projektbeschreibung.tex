% Projektname, Arbeitstitel
% Beschreibung der Projektidee wie im Projektvorschlag nur noch etwas ausführlicher, gestützt auf unsere Features/Use Cases/Assumptions

\section{Projektbeschreibung}

\sepmprojectname soll den Weiterbau einer Plattform darstellen, die es erlaubt, über ein Netzwerk (z.B. das Internet) gemeinsam an Dateien beliebigen Formats zu arbeiten. Es wurde in einem Vorgängerprojekt ein Fat Client entwickelt, der alle Funktionen der im Projekt definierten Synchronisationsschnittstelle benutzt. Die Implementierung der Interclient Communication und Synchronisation Services ist nun als Ausbauphase dieses Projekts durchzuführen. Änderungen an Dateien werden vom Programm erkannt werden und sollen mit Hilfe der Synchronisations- und Interclient Communication Services an andere User propagiert werden. In diesem Projekt soll nur die Phase 2 der folgenden Phaseneinteilung realisiert werden.

\subsection{Phase 1, Fat Client}
In dieser Phase wird das Programm als Fat Client erstellt, dessen grafischen Oberfläche die vollständige Nutzbarkeit der unten aufgeführten Features zugänglich macht. 

Die Netzwerkkommunikation zwischen verschiedenen Clients soll mithilfe eines Mock-Service simuliert werden. Dieser Service wird in dieser Phase die Zusammenarbeit mit anderen Clients simulieren, wodurch die Funktionalität des Programmes getestet werden kann. Neben diesem Mock-Service, welches die Interclient Communication Services der Anwendung kapselt, wird zusätzlich noch ein Synchronisationsinterface erstellt, welches es erlaubt, den Vorgang der Synchronisation zwischen den Clients auf verschiedene Weisen zu implementieren.

Die Synchronisation soll in dieser Phase ebenfalls mithilfe eines Mock-Services realisiert werden. Die Interclient Communication und Synchronisations-Mock-Services können dann, in möglichen späteren Projektphasen, durch entsprechende Implementierungen (z.B. XMPP für das Interclient Communication Service) ersetzt werden. Die für die Synchronisation notwendigen Elemente der Benutzeroberfläche sollen aber bereits in dieser Phase erstellt und an die entsprechenden Schnittstellen gebunden werden. 

\subsubsection{Aufgaben des Interclient Communication Service}
\begin{itemize}
\item Authentifizierung der Benutzer
\item Netzwerkverbindung zwischen den Clients
\item Austausch von Nachrichtenpaketen zwischen den Clients
\item Datenaustausch zwischen den Clients
\end{itemize}
\subsubsection{Aufgaben des Synchronisationsservice}
\begin{itemize}
\item Abholen von Dateiversionen, die andere Projektmitglieder erstellt haben
\item Verbreiten eigener Änderungen
\item Abgleich von Dateiversionen zwischen Clients
\item Erkennen von Dateikonflikten
\end{itemize}
\subsection{Phase 2, Networking / Synchronisation}
Die Mock-Services werden durch konkrete Implementierungen des Interclient Communication Service und des Synchronisationsservice ersetzt. Für das Networkservice ist eine Lösung auf Basis des XMPP-Protokolles angedacht. Durch eine generischen Definition der Schnittstellen in Phase 1 kann dies aber auch mit beliebigen anderen Technologien erfolgen.


Insbesondere muss der Nachrichtenaustausch auf Basis von Daten-Paketen über XMPP gelöst werden, die Authentifizierung gegen XMPP, und die Distribution und Abgleichung der Daten und Metadaten. 
Eine generische XMPP-Library wird für die Grundfunktionalitäten verwendet.

\subsubsection{Weitere Ziele der Projektphase}
\begin{itemize}
\item Umfangreiche Analyse der Programmverwendung und Entwurf zur Überarbeitung des User-Interfaces anhand von Usabilitymaßstäben, sowie Umsetzung.
\item Review der bestehenden Codebasis und Behebung der Mängel.
\item Systemintegration des Programms (Kontextmenüs, Installation) ins Betriebssystem (Windows, Mac).
\end{itemize}

\subsection{Phase 3, Service Sharing}
In dieser Phase ist das zur Verfügung stellen lokaler Services (z.B. Printer Server) zwischen den 
Projektmitgliedern geplant. Dadurch können TCP-Sockets am lokalen Computer oder im lokalen Netzwerk 
an die Projektmitglieder freigegeben werden, die diese dann durch Tunnelling (durch XMPP) benutzen
können. Dazu ist das Tunnelling (mit Kapselung) und das Erkennen von Services zu implementieren.


